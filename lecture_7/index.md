## Транзакции
ACID 
- Atomacity - Атомраность -Транзакци выполняется полностью или не выполнена совсем
- Consistency - Согласованность - После завершения транзакции бд остаётся в согласованном состоянии, то есть не возникает нарушений ограничений целостности
	- ограничения целостности
		- NOT nullUNIQUE
		- PRIMARY key
		- FOREIGN KEY
		- check - проверка условий
		- exclusion constrants - расширенные ограничения
- Isolation - Изоляция  - Параллельные транзакции выполняются так, как если бы они были последовательными, предотвращая конфликты данных
- Durability - Долговечность - После фиксации (COMMIT) изменения остаются в базе данных, даже если система выйдет из строя


## Изоляция транзакций
- read uncomitted - позволяет читаь даже незавершённые изменения других транзакиц (есть в sql, но не в постгресе)
- read commited (по умолчанию) - транзакция видит только зафиксированные (commi) изменения других транзакций
- repeatable read - транзакция видит данные в том виде, в каком они были на момент её начала, даже если другие транзакции вносят изменения
- serializable - максимальный уровень изоляции. Гарантирует, что параллельные транзакции выполняются так, как если бы они шли последовательно


## Аномалии
- Потерянное обновление - такая аномалия возникает, когда две транзакции читают одну и ту же строку таблицы, затем одна транзакция обновляет эту строку, а после этого вторая транзакция тоже обновляет ту же строку, не учитывая изменений, сделанных первой транзакцией
- Грязное чтение - такая аномалия возникает, когда транзакция читает еще не зафиксированные изменения, сделанные другой транзакцией
- Фантомное чтение - возникает тогда, когда транзакция два раза читает набор строк по одному и тому же условию, и в промежутке между чтениями вторая транзакция добавляет строки, удовлетворяющие этому условию (и фиксирует изменения), Тогда первая транзакция получает разные наборы строк

## Serializable
Уровень Serializable должен предотвращать вообще все аномалии. Это означает, что на таком уровне разработчику приложения не надо думать об одновременном выполнении. Если транзакции выполняют корректные последовательности операторов, работая в одиночку, данные будут согласованы и при одновременной работе этих транзакций 

## Аномалии сериализации
- Циклическая зависимость данных (Write skew)

#### Почему именно такие уровни в стандарте?
- Разница между уровнями изоляции стандарта объясняется как раз количеством необходимых блокировок
- Если транзакция блокирует изменяемые строки от изменения, но не от чтения, получаем уровень Read Uncommitted
- Если транзакция блокирует изменяемые строки и от чтения, и от изменения получаем уровень Read Committed
- Если транзакция блокирует и читаемые, и изменяемые строки и от чтения, и от изменения, получаем уровень Repeatable Read
- Но с Serializable проблема: невозможно заблокировать строку, которой еще нет. Из-за этого остается возможность фантомного чтения. поэтому для реализации уровня Serializable обычных блокировок не хватает - нужно блокировать не строки, а условия (предикаты). Такие блокировки и были названы предикатными

## Write-Ahead Logging
- стратегия, при которой все изменения данных сначала записываются в журнал, и только потом применяются к основным файлам базы данных.

	Структура WAL
	- Header (24 байта)
	- Page ID (8 байт)
	- Old Data (Размер страницы)
	- New Data (Размер страницы)
	- Checksum (8 байт)

```pascal
	fsync = on
	synchronous_commit = on
	wal_buffers = 64MB
	```

### synchronous_commit
- on
- off
- local
- remote_write
- remote_apply

### checkpoint
- это процесс, при котором все изменяемые данные из буферного кэша сбрасываются на диск, создавая согласованное состояние базы данных

## хеш-таблица
- данные хранятся в файле, который можно только дополнять (append-only log)
- в оперативной памяти хранится хеш-таблица (словарь)
- ключ → смещение (offset) в файле данных

![](src/4717a2e7b0de60f5444d861705851a10.png)

**Запись**: добавляем пару “ключ-значение” в конец файла и обновляем хещ-таблицу
**Чтение**: по ключу находим смещение в хеш-таблице, переходим по нему в файле и читаем значение

### Сегменты

- Разбить журнал на сегменты фиксированного размера.
- При заполнении сегмента - закрыть его и начать новый
- Запустить фоновый процесс уплотнения (compaction) и слияния (merging) сегментов

### Уплотнение

- Удаление дубликатов ключей
- Сохранение только самой последней версии значения для каждого ключа

### Слияние 
- Объединение нескольких небольших сегментов в один новый
- Позволяет уменьшить общее количество сегментов
![](src/9d933ad7cbbb2edc31587d6e64a4ff5d.png)

### Алгоритм чтения:
- Поиск начинается в хеш-таблице самого свежего сегмента
- Если ключ не найден – проверяется следующий по старшинству сегмент
- И так далее, пока ключ не будет найден или не будут проверены все сегменты

### Только добавление
- Высокая производительность записи: Последовательная запись на диск намного быстрее случайной
- Надежность: Упрощение конкретного доступа и восстановление после сбоев (нет риска “полузаписанных” данных)
- Борьба с фрагментацией: Процесс слияния сегментов естественным образом переписывает данные в компактном виде
## Ограничение 
- Ключи должны помещаться в ОЗУ. Хеш-таблица на диске медленная из-за случайных чтений, дорогого расширения и сложности разрешения коллизий.
- Неэффективные запросы по диапазону. Невозможно быстро найти все ключи от 00000 до 99999. Необходимо обращаться к хеш-таблице для каждого ключа в диапазоне отдельно.

## SS-table

### Особенности 
- Данные отсортированы по ключу
- Каждый ключ встречается только один раз (обеспечивается уплотнением)
- Порядок записи значений не важен - приоритет у более новых значений

### Слияние
- Алгоритм, аналогичный сортировке слиянием
- Работает даже когда данные не помещаются в оперативной памяти
- При конфликте ключей берется значение из самого нового сегмента

### Разряженный индекс

- Не нужно хранить все ключи - только некоторые ориентиры
- Пример: известны смещения для "handbag" и "handsome" → "handiwork" между ними
- Можно быстро просканировать небольшой диапазон

### MemTable
- Сбалансированное дерево в оперативной памяти (красно-черное, AVL)
- Данные сохраняются отсортированными по ключу
- Быстрая вставка в любом порядке
### Надежность 
- Все операции немедленно записываются в журнал
- Журнал неупорядочен - используется только для восстановления
- После записи MemTable в SS-таблицу журнал удаляется

### Алгоритм работы
- Запись: Добавляется в MemTable и параллельно пишется в журнал для надежности
- Чтение: Поиск в MemTable → последнем сегменте - предыдущем и т.д.
- Фоновые процессы: При превышении лимита MemTable записывается в SS-таблицу, Регулярное слияние и уплотнение сегментов

### Фильтр Блума
- Эффективная проверка отсутствия ключа
- Избегание ненужных чтений с диска
- "Возможно есть" / "Точно нет"

## Write-Ahead Log
- Файл только для добавления (append-only)
- Быстрая последовательная запись
- Используется для восстановления после сбоев

## Защелки (latches)

- Облегченные версии блокировок
- Защита структур данных при одновременном доступе
- Высокая производительность



- LSM-деревья: Обычно быстрее при записи
- В-деревья: Обычно быстрее при чтении

## Модель доступа

### Дискреционная модель доступа

- Модель управления доступом, при которой владельцы объектов (например, таблиц, схем, представлений) в базе данных самостоятельно определяют, кто и какие действия может выполнять с этими объектами.

## Роли
- B PostgreSQL понятие "пользователь" является частным случаем роли. Каждая роль может иметь или не иметь возможность входа в систему (login privilege). Если у роли установлено свойство LOGIN, она может использоваться как учетная запись пользователя.
- Роли могут быть членами других ролей. Это позволяет организовать группы пользователей - например, создать роль developers, которой будут принадлежать все разработчики, и назначить этой роли общие привилегии.

- Создание CREATE ROLE (Name} {attr, attr2, ...}
- Изменение ALTER ROLE developer WITH PASSWORD 'newsecret';
- LOGIN
- SUPERUSER
- CREATEDB
- CREATEROLE
- PASSWORD 'secret'

### Наследование привилегий
- роль, являющаяся членом другой роли, по умолчанию автоматически наследует все привилегии (права доступа) этой родительской роли.
- GRANT role1 to role2
- REVOKE role1 FROM role2


#### Привилегии таблиц
- SELECT
- INSERT
- UPDATE
- REFERENCES
- DELETE
- TRUNCATE
- TRIGGER

### Привилегии БД
- CREATE
- CONNECT
- TEMPERARY

%%Оффтоп
Truncate

- TRUNCATE не проверяет каждую строку для удаления, а просто освобождает данные, удаляя содержимое таблицы целиком.
- Вместо того, чтобы логировать каждое удаление строки, TRUNCATE записывает в журнал меньший объем информации.
- При использовании TRUNCATE не вызываются триггеры, определенные для операций удаления.
- Если TRUNCATE выполняется в транзакционном блоке, то операция может быть отменена командой ROLLBACK до фиксации транзакции.%%
  
### Привилегии схем
- CREATE
- USAGE
- Права доступа к схеме влияют на возможность создания новых объектов, но сами по себе не контролируют доступ к уже существующим объектам. Для этого необходимо назначать соответствующие привилегии непосредственно на уровне объектов
